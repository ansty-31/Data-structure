[TOC]
# 数据结构的基本概念
## 数据结构的定义
**数据**：描述客观事物的数和字符的集合
**数据元素**：数据的**基本单元**，也称为元素、结点、顶点或者记录等
**数据项**：具有独立含义的**数据最小单元**，也成为字段或域
（*一个数据元素若干个数据项组成*）
**数据对象**：指**性质相同的数据元素的集合**，是数据的一个子集
（*本课中讨论的数据通常指数据对象*）
==数据结构==：是指==所有数据元素以及数据元素之间的关系==，可以看作是相互之间存在着某种特定关系的数据元素的集合——==数据+结构==
<span style="color:#ff9999;">$$
\text{数据结构} = 
\begin{cases}
\text{逻辑结构：} & \text{由数据元素之间的逻辑关系构成} \\
\text{存储结构：} & \text{数据元素及其在计算机存储器中的存储表示，也称为物理结构} 
\end{cases}
$$</span>
**数据的运算**：施加在该数据上的操作

## 逻辑结构
数据的逻辑结构是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中提炼出来的
### 逻辑结构的表示
可以采用多种形式表示，常见的有图表和二元组
1. **图表表示**：采用表格或者图形直接描述数据的逻辑关系
2. **二元组表示**：
> $B=(D,R)$
> $D=\{d_i|1 \le i \le n, n \ge 0\} \quad \text{{表示数据元素的集合}}$
> $R=\{r_j|1 \le j \le m, m \ge 0\} \quad \text{{表示D上二元关系的集合}}$

&emsp;&emsp;其中R中的一个**关系r是序偶的集合**，对于**r中的任一序偶<x,y>**（x,y∈D），表示元素x和y之间是相邻的，即**x为y的直接前驱元素，y为x的直接后继元素**——若没有前驱元素，则该元素为**开始元素**；若没用后继元素，则该元素为**终端元素**

### 逻辑结构的类型
1. **集合——无联系，最松散**，只要求元素之间“同属于一个集合”即可
2. **线性结构——数据元素之间存在一对一的关系**，例如线性表
3. **树形结构——存在一对多的关系**，例如二叉树
4. **图形结构——存在多对多的关系**，见图论

## 存储结构
1. **顺序存储结构**：采用一组连续的存储单元存放所有的数据元素
2. **链式存储结构**：每个逻辑元素用一个内存结点存储，每个结点单独分配，所有的结点地址未必连续
3. **索引存储结构**：在存储数据元素信息的同时还建立附加的索引表——“关键字+地址”
4. **哈希（或散列）存储结构**：通过哈希（或散列）函数得到的哈希地址存储，与上面三种的区别是，只存储元素的数据，不存储元素的逻辑关系

## 数据运算
1. 运算定义：对运算功能的描述，是抽象的，基于逻辑的
2. 运算实现：完成运算的实现算法，是具体的，基于存储结构的

## 数据类型和抽象数据类型
### 数据类型
一组性质相同的值的集合和定义在此集合上的一组操作的总称，是某种程序设计语言中以实现的数据结构
以C/C++语言为例
1. 基本数据类型：int(4个字节) bool float(8个字节) double(8个字节) char(1个字节)
2. 指针数据类型
3. 数组类型
4. 结构体类型
5. 共用体类型
6. 自定义类型
对于这些变量类型的存储空间分配：静态存储空间分配和动态存储空间分配
### 抽象数据类型
ADT：一般采用（D,S,P）三元组表示——数据对象+数据关系+基本运算
>ADT = 数据结构（数据对象和逻辑关系）+数据运算（运算功能描述）

两个重要特征：数据抽象与数据封装

# 算法与其算法分析
## 算法及其描述
**定义**：算法是对特点问题求解步骤的一种描述，它是指令的有限序列
**特性：有穷性 确定性 可行性 有输入 有输出**
**目标：正确性 可使用性 可读性 健壮性 高效率与低存储量需求**
本项目使用C/C++语言来描述算法

## 算法分析
### 时间性能分析
**方法**：事后统计法与事前估算法，主要采用事情估算法
**时间复制度**：所有原操作的执行次数（也称为频度）$T(n)$的数量级，记作$T(n) = O(f(n))$——实际上是一种时间增长趋势分析（而非绝对时间的比较）
**做法**：只需要$T(n)$的最高阶
>$O(1) < O(\log_{2}n) < O(n) < O(n\log_{2}n) < O(n^2) < O(n^3) < O(2^n) < O(n!)$

注：
$$
\begin{aligned}
& O(1) \text{常数阶} \quad O(n)\text{线性阶} \\
& O(\log_{2}n) 、O(n)、O(n\log_{2}n)、O(n^2)、 O(n^3) \text{多项式时间复杂度——P问题} \\ 
& O(2^n) 、 O(n!)\text{指数时间复杂度——NP问题}
\end{aligned}
$$
**求和定理**：$T_1(n)+T_2(n)=O(MAX())$
**求积定理**：$T_1(n)+T_2(n)=O(f(n)×g(n))$
**算法的最好、最坏和平均时间复杂度**：默认指的是平均时间复杂度

#### 递归算法时间的复杂度分析——变长时空分析
由于递归算法中会出现调用自己的情况，故针对递归的复杂度分析需要**时间的递推式**

### 空间性能分析
**只考虑临时变量所占的空间**
定义和分类，还有针对递归算法的分析下，都与时间复杂度类似，不再做陈述

