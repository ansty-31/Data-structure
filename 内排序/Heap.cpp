#include <stdio.h>
#include <malloc.h>
#include <chrono>

#define MAXSIZE 300

//堆的结点的定义
typedef int KeyType;
typedef char InfoType;

typedef struct
{
    KeyType key;     //关键字
    InfoType data;   //数据项
}RecType;   //每个数据元素的定义

//堆的定义(顺序表类型)
typedef struct 
{
    RecType R[MAXSIZE];
    int length;
}Heap;


//插入法(大顶堆为例)
bool HeapInsert(Heap *H,RecType T)
{
    int curr,p;
    if(H->length==MAXSIZE) return false;
    curr=H->length++;
    H->R[curr]=T;
    p=curr/2;
    while (curr>1&&(H->R[p]).key<T.key)
    {
        RecType temp=H->R[p];
        H->R[p]=T;
        H->R[curr]=temp;
        curr=p;
        p=curr/2;
    }
    return true;
}

//筛选法（以大顶堆为例）
void SiftDown(Heap *H,int pos)   //对内部结点i为根的子树进行筛选
{
    RecType temp=H->R[pos];
    int lc=2*pos;
    while (lc<H->length)
    {
        if (lc<H->length&&H->R[lc].key<H->R[lc+1].key)
        {
            lc++;  //选取孩子中最大的
        }
        if (temp.key<H->R[lc].key)
        {
            H->R[pos]=H->R[lc]; 
            pos=lc;
            lc=2*pos;  //筛子一直筛下去
        }
        else break; //不用筛的话
    }
    H->R[pos]=temp; //注意到是temp在一直往下筛
}
void BuildHeap(Heap *H)
{
    for(int i=H->length/2;i>=0;i--)
        SiftDown(H,i);
}

//取出堆顶（以大顶堆为例）
RecType RemoveMax(Heap *H)
{
    if(H->length==0) 
    {
        printf("empty Heap!");
    }
    RecType temp=H->R[0];
    if(--H->length!=0) //要是只要一个结点，也不必筛了，length减1顺手的事情
    {
        H->R[0]=H->R[H->length];  //删除根结点，并把最后一个元素代替根结点
        SiftDown(H,0);
    }
    return temp;  
}

//堆排序，nlogn,nlogn,nlogn,1，也属于选择排序类型，不稳定
void HeapSort(Heap *H)
{
    BuildHeap(H);
    int n=H->length;
    for(int i = n-1; i > 0; i--)
    {
        RecType max = RemoveMax(H);
        H->R[H->length] = max;
    }
    H->length=n;
}

int main()
{
    Heap *H=(Heap*)malloc(sizeof(Heap));
    H->length=0;
    // 测试数据
    auto start = std::chrono::high_resolution_clock::now();
    RecType data[] = 
    {
    {289,'Q'}, {288,'I'}, {287,'A'}, {286,'B'}, {285,'C'}, {284,'D'}, {283,'E'}, {282,'F'}, {281,'G'}, {280,'H'},
    {279,'I'}, {278,'J'}, {277,'K'}, {276,'L'}, {275,'M'}, {274,'N'}, {273,'O'}, {272,'P'}, {271,'Q'}, {270,'R'},
    {269,'S'}, {268,'T'}, {267,'U'}, {266,'V'}, {265,'W'}, {264,'X'}, {263,'Y'}, {262,'Z'}, {261,'A'}, {260,'B'},
    {259,'C'}, {258,'D'}, {257,'E'}, {256,'F'}, {255,'G'}, {254,'H'}, {253,'I'}, {252,'J'}, {251,'K'}, {250,'L'},
    {249,'M'}, {248,'N'}, {247,'O'}, {246,'P'}, {245,'Q'}, {244,'R'}, {243,'S'}, {242,'T'}, {241,'U'}, {240,'V'},
    {239,'W'}, {238,'X'}, {237,'Y'}, {236,'Z'}, {235,'A'}, {234,'B'}, {233,'C'}, {232,'D'}, {231,'E'}, {230,'F'},
    {229,'G'}, {228,'H'}, {227,'I'}, {226,'J'}, {225,'K'}, {224,'L'}, {223,'M'}, {222,'N'}, {221,'O'}, {220,'P'},
    {219,'Q'}, {218,'R'}, {217,'S'}, {216,'T'}, {215,'U'}, {214,'V'}, {213,'W'}, {212,'X'}, {211,'Y'}, {210,'Z'},
    {209,'A'}, {208,'B'}, {207,'C'}, {206,'D'}, {205,'E'}, {204,'F'}, {203,'G'}, {202,'H'}, {201,'I'}, {200,'J'},
    {199,'K'}, {198,'L'}, {197,'M'}, {196,'N'}, {195,'O'}, {194,'P'}, {193,'Q'}, {192,'R'}, {191,'S'}, {190,'T'},
    {189,'U'}, {188,'V'}, {187,'W'}, {186,'X'}, {185,'Y'}, {184,'Z'}, {183,'A'}, {182,'B'}, {181,'C'}, {180,'D'},
    {179,'E'}, {178,'F'}, {177,'G'}, {176,'H'}, {175,'I'}, {174,'J'}, {173,'K'}, {172,'L'}, {171,'M'}, {170,'N'},
    {169,'O'}, {168,'P'}, {167,'Q'}, {166,'R'}, {165,'S'}, {164,'T'}, {163,'U'}, {162,'V'}, {161,'W'}, {160,'X'},
    {159,'Y'}, {158,'Z'}, {157,'A'}, {156,'B'}, {155,'C'}, {154,'D'}, {153,'E'}, {152,'F'}, {151,'G'}, {150,'H'},
    {149,'I'}, {148,'J'}, {147,'K'}, {146,'L'}, {145,'M'}, {144,'N'}, {143,'O'}, {142,'P'}, {141,'Q'}, {140,'R'},
    {139,'S'}, {138,'T'}, {137,'U'}, {136,'V'}, {135,'W'}, {134,'X'}, {133,'Y'}, {132,'Z'}, {131,'A'}, {130,'B'},
    {129,'C'}, {128,'D'}, {127,'E'}, {126,'F'}, {125,'G'}, {124,'H'}, {123,'I'}, {122,'J'}, {121,'K'}, {120,'L'},
    {119,'M'}, {118,'N'}, {117,'O'}, {116,'P'}, {115,'Q'}, {114,'R'}, {113,'S'}, {112,'T'}, {111,'U'}, {110,'V'},
    {109,'W'}, {108,'X'}, {107,'Y'}, {106,'Z'}, {105,'A'}, {104,'B'}, {103,'C'}, {102,'D'}, {101,'E'}, {100,'F'},
    {99,'G'}, {98,'H'}, {97,'I'}, {96,'J'}, {95,'K'}, {94,'L'}, {93,'M'}, {92,'N'}, {91,'O'}, {90,'P'},
    {89,'Q'}, {88,'R'}, {87,'S'}, {86,'T'}, {85,'U'}, {84,'V'}, {83,'W'}, {82,'X'}, {81,'Y'}, {80,'Z'},
    {79,'A'}, {78,'B'}, {77,'C'}, {76,'D'}, {75,'E'}, {74,'F'}, {73,'G'}, {72,'H'}, {71,'I'}, {70,'J'},
    {69,'K'}, {68,'L'}, {67,'M'}, {66,'N'}, {65,'O'}, {64,'P'}, {63,'Q'}, {62,'R'}, {61,'S'}, {60,'T'},
    {59,'U'}, {58,'V'}, {57,'W'}, {56,'X'}, {55,'Y'}, {54,'Z'}, {53,'A'}, {52,'B'}, {51,'C'}, {50,'D'},
    {49,'E'}, {48,'F'}, {47,'G'}, {46,'H'}, {45,'I'}, {44,'J'}, {43,'K'}, {42,'L'}, {41,'M'}, {40,'N'},
    {39,'O'}, {38,'P'}, {37,'Q'}, {36,'R'}, {35,'S'}, {34,'T'}, {33,'U'}, {32,'V'}, {31,'W'}, {30,'X'},
    {29,'Y'}, {28,'Z'}, {27,'A'}, {26,'B'}, {25,'C'}, {24,'D'}, {23,'E'}, {22,'F'}, {21,'G'}, {20,'H'},
    {19,'I'}, {18,'J'}, {17,'K'}, {16,'L'}, {15,'M'}, {14,'N'}, {13,'O'}, {12,'P'}, {11,'Q'}, {10,'R'},
    {9,'S'}, {8,'T'}, {7,'U'}, {6,'V'}, {5,'W'}, {4,'X'}, {3,'Y'}, {2,'Z'}, {1,'A'}, {0,'B'}
    };
    int n = sizeof(data) / sizeof(data[0]);
    H->length=n;
    for(int i = 0; i < n; i++)
    {
        H->R[i] = data[i];
    }
    HeapSort(H);
    auto end = std::chrono::high_resolution_clock::now();
    auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    printf("堆排序耗时: %lld 纳秒\n", ns.count());
    for(int i = 0; i < H->length; i++) {
        printf("(%d, %c) ", H->R[i].key, H->R[i].data);
    }
    return 0;
}