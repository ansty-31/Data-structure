#include <stdio.h>
#include <malloc.h>
#include <chrono>

typedef int KeyType;
typedef char InfoType;

typedef struct
{
    KeyType key;     //关键字
    InfoType data;   //数据项
}RecType;   //每个数据元素的定义

//归并两个有序表
void Merge(RecType R[],int low, int mid, int high)
{
    RecType *R1;
    int i=low, j=mid+1, k=0;
    R1=(RecType *)malloc((high-low+1)*sizeof(RecType));
    while (i<=mid&&j<=high)
    {
        if(R[i].key<=R[j].key)
        {
            R1[k]=R[i];
            i++;k++;
        }
        else
        {
            R1[k]=R[j];
            j++;k++;
        }
    }
    while (i<=mid)
    {
        R1[k]=R[i];
        i++;k++;
    }
    while (j<=high)
    {
        R1[k]=R[j];
        j++;k++;
    }
    for(k=0,i=low;i<=high;k++,i++)
    {
        R[i]=R1[k];
    }
    free(R1);
}
void MergePass(RecType R[],int length,int n)
{
    int i;
    for(i=0;i+2*length-1<n;i=i+2*length)
    {
        Merge(R,i,i+length-1,i+2*length-1);
    }
    if(i+length-1<n-1)  //子表个数为级数不管，多出来那个轮空就行，要注意的是最后一个子表的区间上界为n-1
    {
        Merge(R,i,i+length-1,n-1);
    }
}

//二路归并排序(从局部到整体) nlogn,nlogn,nlogn,n
void MergeSort(RecType R[],int n)
{
    int length;
    for(length=1;length<n;length=2*length)
    {
        MergePass(R,length,n);
    }
}

//也可以自顶向下(从整体到局部)的递归
void MergeSortDC(RecType R[],int low,int high)
{
    int mid;
    if(low<high)
    {
        mid=(low+high)/2;
        MergeSortDC(R,low,mid);
        MergeSortDC(R,mid+1,high);
        Merge(R,low,mid,high);
    }
}
void MergeSort1(RecType R[],int n)
{
    MergeSortDC(R,0,n-1);
}


int main()
{
    // 测试数据
    auto start = std::chrono::high_resolution_clock::now();
    RecType R[] = 
    {
    {289,'Q'}, {288,'I'}, {287,'A'}, {286,'B'}, {285,'C'}, {284,'D'}, {283,'E'}, {282,'F'}, {281,'G'}, {280,'H'},
    {279,'I'}, {278,'J'}, {277,'K'}, {276,'L'}, {275,'M'}, {274,'N'}, {273,'O'}, {272,'P'}, {271,'Q'}, {270,'R'},
    {269,'S'}, {268,'T'}, {267,'U'}, {266,'V'}, {265,'W'}, {264,'X'}, {263,'Y'}, {262,'Z'}, {261,'A'}, {260,'B'},
    {259,'C'}, {258,'D'}, {257,'E'}, {256,'F'}, {255,'G'}, {254,'H'}, {253,'I'}, {252,'J'}, {251,'K'}, {250,'L'},
    {249,'M'}, {248,'N'}, {247,'O'}, {246,'P'}, {245,'Q'}, {244,'R'}, {243,'S'}, {242,'T'}, {241,'U'}, {240,'V'},
    {239,'W'}, {238,'X'}, {237,'Y'}, {236,'Z'}, {235,'A'}, {234,'B'}, {233,'C'}, {232,'D'}, {231,'E'}, {230,'F'},
    {229,'G'}, {228,'H'}, {227,'I'}, {226,'J'}, {225,'K'}, {224,'L'}, {223,'M'}, {222,'N'}, {221,'O'}, {220,'P'},
    {219,'Q'}, {218,'R'}, {217,'S'}, {216,'T'}, {215,'U'}, {214,'V'}, {213,'W'}, {212,'X'}, {211,'Y'}, {210,'Z'},
    {209,'A'}, {208,'B'}, {207,'C'}, {206,'D'}, {205,'E'}, {204,'F'}, {203,'G'}, {202,'H'}, {201,'I'}, {200,'J'},
    {199,'K'}, {198,'L'}, {197,'M'}, {196,'N'}, {195,'O'}, {194,'P'}, {193,'Q'}, {192,'R'}, {191,'S'}, {190,'T'},
    {189,'U'}, {188,'V'}, {187,'W'}, {186,'X'}, {185,'Y'}, {184,'Z'}, {183,'A'}, {182,'B'}, {181,'C'}, {180,'D'},
    {179,'E'}, {178,'F'}, {177,'G'}, {176,'H'}, {175,'I'}, {174,'J'}, {173,'K'}, {172,'L'}, {171,'M'}, {170,'N'},
    {169,'O'}, {168,'P'}, {167,'Q'}, {166,'R'}, {165,'S'}, {164,'T'}, {163,'U'}, {162,'V'}, {161,'W'}, {160,'X'},
    {159,'Y'}, {158,'Z'}, {157,'A'}, {156,'B'}, {155,'C'}, {154,'D'}, {153,'E'}, {152,'F'}, {151,'G'}, {150,'H'},
    {149,'I'}, {148,'J'}, {147,'K'}, {146,'L'}, {145,'M'}, {144,'N'}, {143,'O'}, {142,'P'}, {141,'Q'}, {140,'R'},
    {139,'S'}, {138,'T'}, {137,'U'}, {136,'V'}, {135,'W'}, {134,'X'}, {133,'Y'}, {132,'Z'}, {131,'A'}, {130,'B'},
    {129,'C'}, {128,'D'}, {127,'E'}, {126,'F'}, {125,'G'}, {124,'H'}, {123,'I'}, {122,'J'}, {121,'K'}, {120,'L'},
    {119,'M'}, {118,'N'}, {117,'O'}, {116,'P'}, {115,'Q'}, {114,'R'}, {113,'S'}, {112,'T'}, {111,'U'}, {110,'V'},
    {109,'W'}, {108,'X'}, {107,'Y'}, {106,'Z'}, {105,'A'}, {104,'B'}, {103,'C'}, {102,'D'}, {101,'E'}, {100,'F'},
    {99,'G'}, {98,'H'}, {97,'I'}, {96,'J'}, {95,'K'}, {94,'L'}, {93,'M'}, {92,'N'}, {91,'O'}, {90,'P'},
    {89,'Q'}, {88,'R'}, {87,'S'}, {86,'T'}, {85,'U'}, {84,'V'}, {83,'W'}, {82,'X'}, {81,'Y'}, {80,'Z'},
    {79,'A'}, {78,'B'}, {77,'C'}, {76,'D'}, {75,'E'}, {74,'F'}, {73,'G'}, {72,'H'}, {71,'I'}, {70,'J'},
    {69,'K'}, {68,'L'}, {67,'M'}, {66,'N'}, {65,'O'}, {64,'P'}, {63,'Q'}, {62,'R'}, {61,'S'}, {60,'T'},
    {59,'U'}, {58,'V'}, {57,'W'}, {56,'X'}, {55,'Y'}, {54,'Z'}, {53,'A'}, {52,'B'}, {51,'C'}, {50,'D'},
    {49,'E'}, {48,'F'}, {47,'G'}, {46,'H'}, {45,'I'}, {44,'J'}, {43,'K'}, {42,'L'}, {41,'M'}, {40,'N'},
    {39,'O'}, {38,'P'}, {37,'Q'}, {36,'R'}, {35,'S'}, {34,'T'}, {33,'U'}, {32,'V'}, {31,'W'}, {30,'X'},
    {29,'Y'}, {28,'Z'}, {27,'A'}, {26,'B'}, {25,'C'}, {24,'D'}, {23,'E'}, {22,'F'}, {21,'G'}, {20,'H'},
    {19,'I'}, {18,'J'}, {17,'K'}, {16,'L'}, {15,'M'}, {14,'N'}, {13,'O'}, {12,'P'}, {11,'Q'}, {10,'R'},
    {9,'S'}, {8,'T'}, {7,'U'}, {6,'V'}, {5,'W'}, {4,'X'}, {3,'Y'}, {2,'Z'}, {1,'A'}, {0,'B'}
    };
    MergeSort(R,290);
    auto end = std::chrono::high_resolution_clock::now();
    auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    printf("归并排序耗时: %lld 纳秒\n", ns.count());
    for(int i = 0; i < 290; i++) {
        printf("(%d, %c) ", R[i].key, R[i].data);
    }
    return 0;
}